import sys

# Python 3.x 버전 확인 (PEP 8 준수를 위해 스크립트 상단에 import)
# 이 스크립트 실행에 필수는 아니지만, 환경 요구사항을 명시합니다.
if sys.version_info < (3, 0):
    print('이 코드는 Python 3.x 이상에서 실행해야 합니다.')
    sys.exit(1)


class Node:
    """
    이진 탐색 트리의 개별 노드를 나타내는 클래스입니다.
    """
    def __init__(self, value):
        """
        노드 생성자.

        Args:
            value: 노드에 저장할 값 (키).
        """
        self.value = value
        self.left = None
        self.right = None


class BinarySearchTree:
    """
    이진 탐색 트리(BST)를 구현한 클래스입니다.
    insert, find, delete 기능을 제공합니다.
    """

    def __init__(self):
        """
        비어있는 이진 탐색 트리를 생성합니다.
        """
        self.root = None

    def insert(self, value):
        """
        트리에 새로운 값을 추가합니다. (공개 메서드)

        Args:
            value: 트리에 삽입할 값.
        """
        if self.root is None:
            # 트리가 비어있으면 새 노드를 루트로 설정
            self.root = Node(value)
        else:
            # 루트 노드부터 시작하여 삽입 위치를 재귀적으로 찾음
            self._insert_recursive(self.root, value)

    def _insert_recursive(self, current_node, value):
        """
        insert()를 위한 재귀 헬퍼 함수입니다. (비공개 메서드)

        Args:
            current_node: 현재 비교 중인 노드.
            value: 삽입할 값.
        """
        if value < current_node.value:
            # 값이 현재 노드보다 작으면 왼쪽 서브트리로 이동
            if current_node.left is None:
                current_node.left = Node(value)
            else:
                self._insert_recursive(current_node.left, value)
        elif value > current_node.value:
            # 값이 현재 노드보다 크면 오른쪽 서브트리로 이동
            if current_node.right is None:
                current_node.right = Node(value)
            else:
                self._insert_recursive(current_node.right, value)
        # else: (value == current_node.value)
        # 값이 이미 트리에 존재하는 경우, 중복을 허용하지 않고 아무것도 하지 않음.
        # (요구사항에 따라 중복을 허용하도록 수정할 수 있습니다.)

    def find(self, value):
        """
        트리에서 특정 값의 존재 유무를 확인합니다. (공개 메서드)

        Args:
            value: 찾고자 하는 값.

        Returns:
            bool: 값이 트리에 존재하면 True, 그렇지 않으면 False.
        """
        return self._find_recursive(self.root, value)

    def _find_recursive(self, current_node, value):
        """
        find()를 위한 재귀 헬퍼 함수입니다. (비공개 메서드)

        Args:
            current_node: 현재 비교 중인 노드.
            value: 찾고자 하는 값.

        Returns:
            bool: 값이 트리에 존재하면 True, 그렇지 않으면 False.
        """
        if current_node is None:
            # 트리의 끝(리프 노드의 자식)에 도달했으나 찾지 못함
            return False
        
        if current_node.value == value:
            # 값을 찾음
            return True
        elif value < current_node.value:
            # 값이 현재 노드보다 작으면 왼쪽 서브트리 탐색
            return self._find_recursive(current_node.left, value)
        else:
            # 값이 현재 노드보다 크면 오른쪽 서브트리 탐색
            return self._find_recursive(current_node.right, value)

    def delete(self, value):
        """
        트리에서 특정 값을 삭제합니다. (공개 메서드)
        삭제 후 트리의 루트가 변경될 수 있으므로 self.root를 업데이트합니다.

        Args:
            value: 삭제하고자 하는 값.
        """
        self.root = self._delete_recursive(self.root, value)

    def _find_min_node(self, node):
        """
        주어진 노드를 루트로 하는 서브트리에서 최소값 노드를 찾습니다.
        (delete 헬퍼 함수)

        Args:
            node: 서브트리의 루트 노드.

        Returns:
            Node: 최소값을 가진 노드.
        """
        current = node
        # 왼쪽 자식이 없을 때까지 계속 왼쪽으로 이동
        while current and current.left is not None:
            current = current.left
        return current

    def _delete_recursive(self, current_node, value):
        """
        delete()를 위한 재귀 헬퍼 함수입니다. (비공개 메서드)
        삭제가 일어난 후 해당 위치를 대체할 노드를 반환합니다.

        Args:
            current_node: 현재 비교 중인 노드.
            value: 삭제하고자 하는 값.

        Returns:
            Node: 삭제 연산 후 현재 위치를 대체할 노드 (또는 None).
        """
        # 기본 케이스 (Base case): 노드가 None이면 그대로 반환
        if current_node is None:
            return current_node

        # 1. 삭제할 노드 탐색
        if value < current_node.value:
            # 값이 작으면 왼쪽 서브트리에서 삭제 진행
            current_node.left = self._delete_recursive(current_node.left, value)
        elif value > current_node.value:
            # 값이 크면 오른쪽 서브트리에서 삭제 진행
            current_node.right = self._delete_recursive(current_node.right, value)
        else:
            # 2. 삭제할 노드 발견 (current_node.value == value)

            # 케이스 1: 자식 노드가 없거나 하나만 있는 경우
            if current_node.left is None:
                # 왼쪽 자식이 없으면 오른쪽 자식을 (있든 없든) 반환하여 연결
                temp = current_node.right
                # current_node = None (메모리 해제, Python은 가비지 컬렉터가 처리)
                return temp
            elif current_node.right is None:
                # 오른쪽 자식이 없으면 왼쪽 자식을 반환하여 연결
                temp = current_node.left
                # current_node = None
                return temp

            # 케이스 2: 자식 노드가 둘 다 있는 경우
            # (전략: 오른쪽 서브트리에서 가장 작은 값(In-order Successor)을 찾음)
            
            # 2-1. 오른쪽 서브트리에서 최소값 노드 찾기
            temp_node = self._find_min_node(current_node.right)

            # 2-2. 현재 노드의 값을 찾은 최소값으로 교체
            current_node.value = temp_node.value

            # 2-3. 오른쪽 서브트리에서 이제 중복된 최소값 노드(temp_node)를 삭제
            current_node.right = self._delete_recursive(current_node.right, temp_node.value)

        # 3. (삭제가 발생했거나 발생하지 않았더라도) 현재 노드를 상위 호출로 반환
        return current_node

    def inorder_traversal(self):
        """
        (참고용) 중위 순회(in-order traversal) 결과를 리스트로 반환합니다.
        BST의 중위 순회 결과는 항상 정렬된 리스트입니다.
        """
        result = []
        self._inorder_recursive(self.root, result)
        return result

    def _inorder_recursive(self, node, result_list):
        """
        중위 순회 헬퍼 함수
        """
        if node:
            self._inorder_recursive(node.left, result_list)
            result_list.append(node.value)
            self._inorder_recursive(node.right, result_list)


# --- 코드 실행 예제 (Test cases) ---
# 이 스크립트가 직접 실행될 때만 아래 코드가 동작합니다.
if __name__ == '__main__':
    
    # 문제에서 요구한 'binarytree' 이름으로 인스턴스 생성
    # (보너스 과제인 BinarySearchTree 클래스 사용)
    binarytree = BinarySearchTree()

    print('--- 1. Insert (삽입) ---')
    nodes_to_insert = [50, 30, 70, 20, 40, 60, 80]
    print(f'삽입할 노드들: {nodes_to_insert}')
    for node_val in nodes_to_insert:
        binarytree.insert(node_val)
    
    print(f'중위 순회 (정렬) 결과: {binarytree.inorder_traversal()}')

    print('\n--- 2. Find (탐색) ---')
    find_val_exist = 40
    find_val_not_exist = 99
    
    print(f'"{find_val_exist}" 탐색 결과: {binarytree.find(find_val_exist)}')
    print(f'"{find_val_not_exist}" 탐색 결과: {binarytree.find(find_val_not_exist)}')
    
    print('\n--- 3. Delete (삭제) ---')

    # 케이스 1: 리프 노드 삭제 (예: 20)
    print(f'삭제 전 (중위 순회): {binarytree.inorder_traversal()}')
    binarytree.delete(20)
    print(f'리프 노드(20) 삭제 후: {binarytree.inorder_traversal()}')
    print(f'20 탐색 (삭제 확인): {binarytree.find(20)}')

    # 케이스 2: 자식이 하나인 노드 삭제 (예: 30)
    # (20을 삭제했으므로 30은 오른쪽 자식 40만 가짐)
    binarytree.delete(30)
    print(f'자식 하나 노드(30) 삭제 후: {binarytree.inorder_traversal()}')

    # 케이스 3: 자식이 둘인 노드 삭제 (예: 50, 루트 노드)
    # (오른쪽 서브트리[60, 70, 80]의 최소값인 60이 루트가 됨)
    binarytree.delete(50)
    print(f'자식 둘 노드(50, 루트) 삭제 후: {binarytree.inorder_traversal()}')
    print(f'새로운 루트 노드 값: {binarytree.root.value}')


    # 케이스 4: 존재하지 않는 노드 삭제
    print(f'존재하지 않는 99 삭제 시도 전: {binarytree.inorder_traversal()}')
    binarytree.delete(99)
    print(f'존재하지 않는 99 삭제 시도 후: {binarytree.inorder_traversal()}')